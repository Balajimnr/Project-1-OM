<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Integrated DLT System - Cross Border Transfer & Network Consensus</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 20px;
    background: linear-gradient(135deg, #f0f4f8, #d9e2ec);
    color: #2c3e50;
  }

  .tab-container {
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    overflow: hidden;
    margin-bottom: 20px;
  }

  .tab-header {
    display: flex;
    background: #f8f9fa;
    border-bottom: 1px solid #dee2e6;
  }

  .tab-button {
    flex: 1;
    padding: 15px 20px;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 16px;
    font-weight: 600;
    color: #6c757d;
    transition: all 0.3s ease;
  }

  .tab-button.active {
    background: #1976d2;
    color: white;
  }

  .tab-button:hover {
    background: #e9ecef;
  }

  .tab-button.active:hover {
    background: #1565c0;
  }

  .main-section {
    padding: 20px;
  }

  /* Cross Border Transfer Styles */
  h2 {
    color: #1976d2;
    margin-bottom: 10px;
    margin-top: 0;
  }

  .menu-bar {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    background: #fff;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.1);
    margin-bottom: 25px;
  }

  .menu-item {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  select, input[type=number] {
    padding: 5px 8px;
    font-size: 1rem;
    border-radius: 4px;
    border: 1px solid #ccc;
    min-width: 110px;
  }

  input[type=number] {
    max-width: 110px;
  }

  button {
    background-color: #1976d2;
    border: none;
    color: white;
    padding: 6px 14px;
    font-size: 1rem;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.25s ease;
    white-space: nowrap;
  }

  button:hover {
    background-color: #115293;
  }

  #dashboard {
    display: flex;
    gap: 25px;
    margin-bottom: 30px;
    flex-wrap: wrap;
  }

  .dashboard-section {
    background: #fff;
    box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    padding: 15px 20px;
    border-radius: 8px;
    flex: 1;
    min-width: 300px;
  }

  .dashboard-section h3 {
    margin-top: 0;
    color: #0d47a1;
    margin-bottom: 15px;
  }

  .expandable {
    cursor: pointer;
    color: #1976d2;
    margin-left: 8px;
    user-select: none;
  }

  .hidden {
    display: none;
  }

  .dashboard-section div a {
    color: #1976d2;
    text-decoration: none;
    cursor: pointer;
  }

  .dashboard-section div a:hover {
    text-decoration: underline;
  }

  #ammLiquidityWrapper {
    display: flex;
    gap: 40px;
    margin-bottom: 30px;
    flex-wrap: wrap;
  }

  #liquiditySection, #ammSection {
    flex: 1;
    background: #fff;
    box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    padding: 20px;
    border-radius: 8px;
    min-width: 300px;
  }

  #liquiditySection h3, #ammSection h3 {
    margin-top: 0;
    color: #0d47a1;
    margin-bottom: 10px;
  }

  label {
    font-weight: 600;
    margin-right: 6px;
  }

  /* DLT Network Styles */
  .topbar {
    display: flex;
    gap: 14px;
    align-items: center;
    margin: 12px 0;
  }

  .menu-bar-network {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    background: #fff;
    padding: 12px;
    border-radius: 10px;
    box-shadow: 0 1px 6px rgba(20,40,80,0.06);
  }

  #main {
    display: flex;
    gap: 25px;
    flex-wrap: wrap;
  }

  #networkPanel {
    flex: 1;
    min-width: 360px;
  }

  #networkCanvas {
    width: 320px;
    height: 360px;
    border-radius: 8px;
    background: linear-gradient(180deg,#eef7ff,#ffffff);
    display: block;
  }

  .nodeItem {
    display: flex;
    justify-content: space-between;
    padding: 6px 0;
    border-bottom: 1px dashed #edf5fb;
  }

  .nodeItem:last-child {
    border-bottom: none;
  }

  .nodeBadge {
    font-weight: 700;
  }

  #dashboard-network {
    display: flex;
    flex-direction: column;
    gap: 14px;
    flex: 2;
    min-width: 300px;
  }

  #nodesGrid {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .nodeCard {
    min-width: 140px;
    padding: 10px;
    border-radius: 8px;
    background: linear-gradient(180deg,#fff,#f6fbff);
    border: 1px solid #e6f0fb;
  }

  .mini {
    font-size: 0.9rem;
    color: #235a9a;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
  }

  table th, table td {
    border: 1px solid #ddd;
    padding: 8px 10px;
    text-align: left;
  }
  #interestRateTable, #stakingYieldTable {
    font-size: 0.8rem;
  }
  #interestRateTable th, #interestRateTable td,
  #stakingYieldTable th, #stakingYieldTable td {
    padding: 5px;
  }

  table th {
    background: #e3f2fd;
    color: #0d47a1;
  }

  .muted {
    color: #667d9a;
    font-size: 0.9rem;
  }

  /* Modal Styles */
  #modalOverlay, #auditModalOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.3);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }

  #modal, #auditModal {
    background: white;
    border-radius: 8px;
    max-width: 800px;
    width: 95%;
    max-height: 70vh;
    overflow-y: auto;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    padding: 20px;
    position: relative;
  }

  #modalClose, #auditModalClose {
    position: absolute;
    top: 15px;
    right: 20px;
    font-size: 1.5rem;
    cursor: pointer;
    color: #999;
  }

  #modalClose:hover, #auditModalClose:hover {
    color: #444;
  }

  #modalSearch, #auditSearch {
    margin-bottom: 15px;
    padding: 6px 8px;
    width: 100%;
    font-size: 1rem;
    border-radius: 4px;
    border: 1px solid #ccc;
  }

  @media (max-width: 768px) {
    #main {
      grid-template-columns: 1fr;
    }
    .menu-bar {
      flex-direction: column;
      gap: 10px;
    }
    #dashboard, #ammLiquidityWrapper {
      flex-direction: column;
    }
  }

  #statusModalOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.3);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
  }

  #statusModal {
    background: white;
    border-radius: 8px;
    padding: 20px 30px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    text-align: center;
  }
</style>
</head>
<body>
<div class="tab-container">

  <!-- Tokenised Business Services Section -->
  <div id="crossborder" class="main-section">
    <h2>Tokenised Payments and Liquidity Services</h2>
    <div class="menu-bar" aria-label="Function controls menu">
      <!-- Tokenize -->
      <div class="menu-item" role="group" aria-label="Tokenize funds">
        <label for="tokenizeParticipant">Tokenize:</label>
        <select id="tokenizeParticipant" aria-label="Participant for tokenizing funds"></select>
        <select id="tokenizeCurrency" aria-label="Currency to tokenize"></select>
        <input type="number" id="tokenizeAmount" placeholder="Amount" min="0" step="any" aria-label="Amount to tokenize" />
        <button onclick="tokenizeFromUI()">Go</button>
      </div>
      <!-- Transfer -->
      <div class="menu-item" role="group" aria-label="Transfer tokens">
        <label for="sender">Send:</label>
        <select id="sender" aria-label="Sender participant"></select>
        <label for="receiver">To:</label>
        <select id="receiver" aria-label="Receiver participant"></select>
        <select id="transferCurrency" aria-label="Currency to transfer"></select>
        <input type="number" id="transferAmount" placeholder="Amount" min="0" step="any" aria-label="Amount to transfer" />
        <button onclick="transferFromUI()">Go</button>
      </div>
      <!-- Burn -->
      <div class="menu-item" role="group" aria-label="Burn tokens">
        <label for="burnParticipant">Burn:</label>
        <select id="burnParticipant" aria-label="Participant for burning tokens"></select>
        <select id="burnCurrency" aria-label="Currency to burn"></select>
        <input type="number" id="burnAmount" placeholder="Amount" min="0" step="any" aria-label="Amount to burn" />
        <button onclick="burnTokensUI()">Go</button>
      </div>
      <!-- AMM Swap -->
      <div class="menu-item" role="group" aria-label="Cross currency swap">
        <label for="ammParticipant">Swap:</label>
        <select id="ammParticipant" aria-label="Participant for currency swap"></select>
        <select id="ammFromCurrency" aria-label="Currency to swap from"></select>
        <select id="ammToCurrency" aria-label="Currency to swap to"></select>
        <input type="number" id="ammAmount" placeholder="Amount" min="0" step="any" aria-label="Amount to swap" />
        <button onclick="crossCurrencyTransfer()">Go</button>
      </div>
      <!-- Repay Borrowed -->
      <div class="menu-item" role="group" aria-label="Repay borrowed funds">
        <label for="repayParticipant">Repay:</label>
        <select id="repayParticipant" aria-label="Participant repaying borrowed funds" onchange="populateLoanDropdown()"></select>
        <select id="repayCurrency" aria-label="Currency to repay" onchange="populateLoanDropdown()"></select>
        <select id="repayLoanId" aria-label="Loan to repay"></select>
        <input type="number" id="repayAmount" placeholder="Amount" min="0" step="any" aria-label="Amount to repay" />
        <button onclick="repayBorrowedUI()">Go</button>
      </div>
      <!-- Interest Posting -->
      <div class="menu-item" role="group" aria-label="Post interest on borrowed funds">
        <label for="interestFrequency">Interest freq:</label>
        <select id="interestFrequency" aria-label="Interest posting frequency" style="min-width: 110px;">
          <option value="hour">Hourly</option>
          <option value="day">Daily</option>
          <option value="week">Weekly</option>
          <option value="month" selected>Monthly</option>
        </select>
        <button onclick="postInterest()">Post Interest</button>
        <button onclick="postStakingYield()">Post Staking Yield</button>
      </div>
      <!-- Audit Trail -->
      <div class="menu-item" role="group" aria-label="Open audit trail modal" style="margin-left:auto;">
        <button onclick="openAuditModal()">Audit Trail</button>
      </div>
    </div>
    <!-- Dashboard: Accounts, Wallets, Loans side by side -->
    <div id="dashboard" role="region" aria-label="Dashboard showing accounts, wallets and loans summary">
      <div class="dashboard-section" id="accountsSection" tabindex="0" aria-label="Accounts section">
        <h3>Accounts (Deposits)</h3>
      </div>
      <div class="dashboard-section" id="walletsSection" tabindex="0" aria-label="Wallets section">
        <h3>Wallets (Tokens)</h3>
      </div>
      <div class="dashboard-section" id="loansSection" tabindex="0" aria-label="Loan accounts section">
        <h3>Loan Accounts</h3>
      </div>
    </div>
    <!-- Liquidity & AMM side by side -->
    <div id="ammLiquidityWrapper" aria-label="Liquidity Pool and AMM rates section">
      <section id="liquiditySection" tabindex="0" aria-label="Liquidity Pool balances">
        <h3>Liquidity pool (in millions)</h3>
        <div id="walletBalanceMatrix"></div>
      </section>
      <section id="ammSection" tabindex="0" aria-label="Automated Market Maker rates">
        <h3>AMM Cross-Currency Rate Matrix</h3>
        <div id="ammMatrix"></div>
      </section>
    </div>

    <!-- Rate Tables Container -->
    <div style="display: flex; gap: 25px; margin-bottom: 30px; flex-wrap: wrap;">
        <!-- Interest Rate Table -->
        <div id="interestRateWrapper" style="flex: 1; min-width: 300px;">
            <section class="dashboard-section">
                <h3>Interest Rates</h3>
                <table id="interestRateTable" style="width:100%; margin-top:8px;">
                    <thead>
                        <tr>
                            <th>Currency</th>
                            <th>Deposit Rate</th>
                            <th>Lending Rate</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Will be populated by JavaScript -->
                    </tbody>
                </table>
            </section>
        </div>

        <!-- Staking Yield Table -->
        <div id="stakingYieldWrapper" style="flex: 1; min-width: 300px;">
            <section class="dashboard-section">
                <h3>Staking Yields (per period)</h3>
                <table id="stakingYieldTable" style="width:100%; margin-top:8px;">
                    <thead>
                        <tr>
                            <th>Currency</th>
                            <th>Yield Rate</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Will be populated by JavaScript -->
                    </tbody>
                </table>
            </section>
        </div>
    </div>
  </div>
  <!-- DLT Network Section -->
  <div id="network" class="main-section">
    <h2 style="margin-top: 40px; border-top: 2px solid #dee2e6; padding-top: 20px;">DLT Network View</h2>

    <div id="main">
      <aside id="networkPanel" class="dashboard-section">
        <h3 style="margin-top:0">Network Map</h3>
        <canvas id="networkCanvas"></canvas>
        <div style="margin-top:8px">
          <strong>Nodes</strong>
          <div id="nodesList"></div>
        </div>
      </aside>
      <main id="dashboard-network">
        <section class="dashboard-section">
          <h3 style="margin:0">Nodes & Wallets</h3>
          <div id="nodesGrid"></div>
        </section>
      </main>
    </div>
  </div>
</div>
<!-- Modals -->
<!-- Status Modal -->
<div id="statusModalOverlay" role="dialog" aria-modal="true" aria-labelledby="statusModalTitle">
  <div id="statusModal">
    <h4 id="statusModalTitle">Transaction Status</h4>
    <p id="statusModalMessage"></p>
  </div>
</div>
<!-- Transactions / History Modal -->
<div id="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle" aria-describedby="modalSearch">
  <div id="modal">
    <span id="modalClose" onclick="closeModal()" role="button" tabindex="0" aria-label="Close modal">&times;</span>
    <h4 id="modalTitle"></h4>
    <input type="text" id="modalSearch" placeholder="Search..." oninput="filterModalTable()" aria-label="Search transactions" />
    <table id="modalTable" role="table" aria-describedby="modalTitle">
      <thead><tr><th>Date</th><th>Type</th><th>Details</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</div>
<!-- Audit Trail Modal -->
<div id="auditModalOverlay" role="dialog" aria-modal="true" aria-labelledby="auditModalTitle" aria-describedby="auditSearch">
  <div id="auditModal">
    <span id="auditModalClose" onclick="closeAuditModal()" role="button" tabindex="0" aria-label="Close audit modal">&times;</span>
    <h4 id="auditModalTitle">Consolidated Audit Trail</h4>
    <input type="text" id="auditSearch" placeholder="Search audit..." oninput="filterAuditTable()" aria-label="Search audit trail" />
    <table id="auditTable" role="table" aria-describedby="auditModalTitle">
      <thead><tr><th>Date</th><th>Source</th><th>Event Type</th><th>Details</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</div>
<script>
// ========== SHARED CONFIGURATION ==========
const sovereigns = {
  'Sydney': 'AUD',
  'Tokyo': 'JPY',
  'Singapore': 'SGD',
  'Hong Kong': 'HKD',
  'Dubai': 'USD',
  'London': 'GBP',
  'New York': 'USD'
};
const sovereign_currencies = [...new Set(Object.values(sovereigns))];
const currencies = ['USD', ...sovereign_currencies.filter(c => c !== 'USD')].sort();
const cities = Object.keys(sovereigns);
// ========== SHARED DATA STRUCTURES ==========
let sharedParticipants = {};
let sharedLiquidityPool = {};
let sharedAuditTrail = [];

const INTEREST_RATES = {};
currencies.forEach(c => {
  INTEREST_RATES[c] = { credit: 0.0001, debit: 0.0009 };
});

const STAKING_YIELDS = {};
currencies.forEach(c => {
    STAKING_YIELDS[c] = 0.0002; // Default 0.02% yield per period
});

// ========== SHARED WALLET SYSTEM ==========
function initializeSharedSystem() {
  sharedParticipants = {};
  sharedLiquidityPool = {};
  sharedAuditTrail = [];
  currencies.forEach(c => sharedLiquidityPool[c] = 0);
  cities.forEach(city => {
    sharedParticipants[city] = {
      name: city,
      accounts: {},
      wallets: {},
      loans: {},
      borrowed: {},
      transactions: [],
      lastDepositInterestPostDate: new Date(),
      lastStakingYieldPostDate: new Date(),
      // Network-specific properties
      mempool: [],
      chain: []
    };
    const sovereignCurrency = sovereigns[city];
    currencies.forEach(c => {
      // Initialize only USD and sovereign currency accounts with a balance
      if (c === 'USD' || c === sovereignCurrency) {
        sharedParticipants[city].accounts[c] = 1000000;
      } else {
        sharedParticipants[city].accounts[c] = 0;
      }
      sharedParticipants[city].wallets[c] = 0;
    });
    // Loans and borrowed are no longer per-currency objects, but arrays of loan objects.
    sharedParticipants[city].loans = [];
    sharedParticipants[city].borrowed = [];
  });
  recalcSharedLiquidityPool();
}
function recalcSharedLiquidityPool() {
  currencies.forEach(c => sharedLiquidityPool[c] = 0);
  cities.forEach(city => {
    currencies.forEach(c => {
      sharedLiquidityPool[c] += sharedParticipants[city].wallets[c];
    });
  });
}
function addSharedTransaction(city, type, details) {
  const tx = {
    timestamp: new Date(),
    type,
    details
  };
  sharedParticipants[city].transactions.unshift(tx);
}
function addSharedAudit(msg) {
  sharedAuditTrail.unshift({ timestamp: new Date(), message: msg });
  if (sharedAuditTrail.length > 100) sharedAuditTrail.pop();
}
// ========== TRANSACTION PROCESSING ==========
const statusModalOverlay = document.getElementById('statusModalOverlay');
const statusModalMessage = document.getElementById('statusModalMessage');

function showStatusModal(message) {
    statusModalMessage.textContent = message;
    statusModalOverlay.style.display = 'flex';
}

function hideStatusModal() {
    statusModalOverlay.style.display = 'none';
}

function processTransaction(tx, onSuccessCallback) {
    showStatusModal('Processing transaction...');

    setTimeout(() => {
        try {
            const result = network.broadcastAndConsolidate(tx);

            if (result.success) {
                // Use a timeout to ensure the UI updates after the current execution stack clears.
                setTimeout(() => updateAllDisplays(), 0);
                statusModalMessage.textContent = result.message || 'Transaction Successful!';
                if (onSuccessCallback) {
                    onSuccessCallback();
                }
            } else {
                statusModalMessage.textContent = result.message || 'Transaction Failed!';
            }
        } catch (e) {
            statusModalMessage.textContent = `ERROR: ${e.message}`;
            console.error(e);
        }

        setTimeout(() => {
            hideStatusModal();
        }, 2500); // Keep message visible a bit longer for errors
    }, 500); // Simulate network latency
}
// ========== CROSS BORDER TRANSFER FUNCTIONS ==========
// UI Functions for Cross Border Transfer
function tokenizeFromUI() {
  const participant = document.getElementById('tokenizeParticipant').value;
  const currency = document.getElementById('tokenizeCurrency').value;
  const amount = parseFloat(document.getElementById('tokenizeAmount').value);
  if(isNaN(amount) || amount <= 0) { alert("Invalid amount."); return; }

  const tx = new Transaction({ type: 'tokenize', from: participant, to: participant, currency: currency, amount: amount });
  processTransaction(tx);
}
function transferFromUI() {
    recalcSharedLiquidityPool(); // Recalculate pool at the start of any action
    const senderName = document.getElementById('sender').value;
    const receiverName = document.getElementById('receiver').value;
    const transferCurrency = document.getElementById('transferCurrency').value;
    const transferAmount = parseFloat(document.getElementById('transferAmount').value);

    if (isNaN(transferAmount) || transferAmount <= 0) {
        alert("Invalid amount.");
        return;
    }

    const sender = sharedParticipants[senderName];
    const senderWalletBalance = sender.wallets[transferCurrency];

    // Case 1: Sufficient Funds
    if (senderWalletBalance >= transferAmount) {
        const tx = new Transaction({ type: 'transfer', from: senderName, to: receiverName, currency: transferCurrency, amount: transferAmount });
        processTransaction(tx);
        return;
    }

    // Case 2: Insufficient Funds -> Try Swap or Borrow
    const needed = transferAmount - senderWalletBalance;

    // Find best currency to swap from (simple heuristic: largest balance)
    let bestSwapCandidate = null;
    let maxBalance = 0;
    for (const c in sender.wallets) {
        if (c !== transferCurrency && sender.wallets[c] > maxBalance) {
            maxBalance = sender.wallets[c];
            bestSwapCandidate = c;
        }
    }

    // Check if a swap is possible and prompt user
    if (bestSwapCandidate) {
        network.syncLiquidityService(); // Ensure AMM service has latest liquidity
        const amountNeededFromSwap = network.ammService.getAmountIn(bestSwapCandidate, transferCurrency, needed);
        if (sender.wallets[bestSwapCandidate] >= amountNeededFromSwap) {
            if (confirm(`You are short ${needed.toFixed(2)} ${transferCurrency}. Swap ~${amountNeededFromSwap.toFixed(2)} ${bestSwapCandidate} to complete the transfer?`)) {
                const tx = new Transaction({
                    type: 'swap_and_transfer',
                    from: senderName,
                    to: receiverName,
                    currency: transferCurrency,
                    amount: transferAmount,
                    meta: {
                        swapFrom: bestSwapCandidate,
                        swapAmountIn: amountNeededFromSwap,
                        neededForTransfer: needed
                    }
                });
                processTransaction(tx);
                return; // Exit after creating swap_and_transfer tx
            }
        }
    }

    // Case 3: Fallback to Borrowing
    recalcSharedLiquidityPool();
    const availableToBorrow = sharedLiquidityPool[transferCurrency];
    if (availableToBorrow < needed) {
        alert(`Insufficient funds and swap is not possible. You need ${needed.toFixed(2)} ${transferCurrency}, but only ${availableToBorrow.toFixed(2)} is available to borrow.`);
        return;
    }

    if (confirm(`Swap declined or unavailable. Do you want to borrow ${needed.toFixed(2)} ${transferCurrency} from the liquidity pool instead?`)) {
        const tx = new Transaction({
            type: 'borrow_and_transfer',
            from: senderName,
            to: receiverName,
            currency: transferCurrency,
            amount: transferAmount,
            meta: { borrowAmount: needed }
        });
        processTransaction(tx);
    }
}
function burnTokensUI() {
  const participant = document.getElementById('burnParticipant').value;
  const currency = document.getElementById('burnCurrency').value;
  const amount = parseFloat(document.getElementById('burnAmount').value);
  if(isNaN(amount) || amount <= 0) { alert("Invalid amount."); return; }

  const tx = new Transaction({ type: 'burn', from: participant, to: participant, currency: currency, amount: amount });
  processTransaction(tx);
}
function crossCurrencyTransfer() {
  const participant = document.getElementById('ammParticipant').value;
  const fromCurrency = document.getElementById('ammFromCurrency').value;
  const toCurrency = document.getElementById('ammToCurrency').value;
  const amount = parseFloat(document.getElementById('ammAmount').value);
  if(isNaN(amount) || amount <= 0) { alert("Invalid amount."); return; }

  const tx = new Transaction({ type: 'swap', from: participant, to: participant, meta: { fromCurrency: fromCurrency, toCurrency: toCurrency, amountIn: amount } });
  processTransaction(tx);
}
function populateLoanDropdown() {
    const participantName = document.getElementById('repayParticipant').value;
    const currency = document.getElementById('repayCurrency').value;
    const loanDropdown = document.getElementById('repayLoanId');
    loanDropdown.innerHTML = '';

    const participant = sharedParticipants[participantName];
    const outstandingLoans = participant.borrowed.filter(loan => loan.currency === currency && loan.totalAmount > 0);

    if (outstandingLoans.length === 0) {
        const opt = document.createElement('option');
        opt.textContent = 'No outstanding loans';
        loanDropdown.appendChild(opt);
        loanDropdown.disabled = true;
    } else {
        outstandingLoans.forEach(loan => {
            const opt = document.createElement('option');
            opt.value = loan.loanId;
            opt.textContent = `ID: ${loan.loanId.slice(0, 6)}... (${loan.totalAmount.toFixed(2)} ${loan.currency})`;
            loanDropdown.appendChild(opt);
        });
        loanDropdown.disabled = false;
    }
}

function repayBorrowedUI() {
    recalcSharedLiquidityPool();
    const participantName = document.getElementById('repayParticipant').value;
    const loanId = document.getElementById('repayLoanId').value;
    const amount = parseFloat(document.getElementById('repayAmount').value);

    if (!loanId || loanId === 'No outstanding loans') {
        alert("Please select a valid loan to repay.");
        return;
    }
    if(isNaN(amount) || amount <= 0) { alert("Invalid repay amount."); return; }

    const participant = sharedParticipants[participantName];
    const loanToRepay = participant.borrowed.find(l => l.loanId === loanId);

    if (!loanToRepay) {
        alert("Selected loan not found.");
        return;
    }

    const currency = loanToRepay.currency;
    const repayAmount = Math.min(amount, loanToRepay.totalAmount);
    const walletBalance = participant.wallets[currency];

    // Case 1: Sufficient funds for repayment
    if (walletBalance >= repayAmount) {
        const tx = new Transaction({ type: 'repay', from: participantName, to: participantName, currency: currency, amount: repayAmount, meta: { loanId: loanId } });
        processTransaction(tx);
        return;
    }

    // Case 2: Insufficient funds, try to swap
    const neededFromWallet = repayAmount - walletBalance;
    let bestSwapCandidate = null;
    let maxBalance = 0;
    for (const c in participant.wallets) {
        if (c !== currency && participant.wallets[c] > maxBalance) {
            maxBalance = participant.wallets[c];
            bestSwapCandidate = c;
        }
    }

    if (bestSwapCandidate) {
        network.syncLiquidityService();
        const amountNeededFromSwap = network.ammService.getAmountIn(bestSwapCandidate, currency, neededFromWallet);
        if (participant.wallets[bestSwapCandidate] >= amountNeededFromSwap) {
            if (confirm(`You have an insufficient ${currency} balance to repay. Swap ~${amountNeededFromSwap.toFixed(2)} ${bestSwapCandidate} to proceed?`)) {
                const tx = new Transaction({
                    type: 'swap_and_repay',
                    from: participantName,
                    to: participantName,
                    currency: currency,
                    amount: repayAmount,
                    meta: {
                        loanId: loanId,
                        swapFrom: bestSwapCandidate,
                        swapAmountIn: amountNeededFromSwap
                    }
                });
                processTransaction(tx);
                return;
            }
        }
    }

    // Case 3: Fallback to failure
    alert(`Repayment failed. Insufficient ${currency} balance and no swappable funds available.`);
}
function postInterest() {
  const freq = document.getElementById('interestFrequency').value;
  const now = new Date();
  cities.forEach(city => {
    const participant = sharedParticipants[city];
    // --- New Deposit Interest Logic ---
    const lastDepositPost = participant.lastDepositInterestPostDate || now;
    const diffMsDeposit = now - lastDepositPost;
    let depositPeriods = 0;
    if(freq === 'hour') { depositPeriods = Math.floor(diffMsDeposit / (1000 * 60 * 60)); }
    else { const diffDays = Math.floor(diffMsDeposit / (1000 * 60 * 60 * 24));
        if(freq === 'day') depositPeriods = diffDays;
        else if(freq === 'week') depositPeriods = Math.floor(diffDays / 7);
        else if(freq === 'month') depositPeriods = Math.floor(diffDays / 30);
    }
    if (depositPeriods > 0) {
        for (const c in participant.accounts) {
            if (participant.accounts[c] > 0) {
                const creditRate = INTEREST_RATES[c].credit;
                const interest = participant.accounts[c] * creditRate * depositPeriods;
                participant.accounts[c] += interest;
                addSharedTransaction(city, 'Interest', `Received ${interest.toFixed(2)} ${c} deposit interest.`);
            }
        }
        participant.lastDepositInterestPostDate = now;
    }

    // --- Existing Loan Interest Logic ---
    for (const c in participant.borrowed) {
        const borrowed = participant.borrowed[c];
        if(borrowed.amount <= 0) continue;
        const lastLoanPost = borrowed.lastInterestPostDate || now;
        const diffMsLoan = now - lastLoanPost;
        let loanPeriods = 0;
        if(freq === 'hour') { loanPeriods = Math.floor(diffMsLoan / (1000 * 60 * 60)); }
        else { const diffDays = Math.floor(diffMsLoan / (1000 * 60 * 60 * 24));
            if(freq === 'day') loanPeriods = diffDays;
            else if(freq === 'week') loanPeriods = Math.floor(diffDays / 7);
            else if(freq === 'month') loanPeriods = Math.floor(diffDays / 30);
        }

        if(loanPeriods > 0) {
            const debitRate = INTEREST_RATES[c].debit;
            const interest = borrowed.amount * debitRate * loanPeriods;
            borrowed.amount += interest; // Compound the interest onto the borrowed amount
            // participant.loans[c] += interest; // TODO: Refactor this for new data model
            borrowed.lastInterestPostDate = now;
            addSharedAudit(`Posted ${interest.toFixed(2)} ${c} interest for ${city} on borrowed amount.`);
            addSharedTransaction(city, 'Interest', `Charged ${interest.toFixed(2)} ${c} loan interest.`);
        }
    }
  });
  updateAllDisplays();
}
function postStakingYield() {
    const freq = document.getElementById('interestFrequency').value;
    const now = new Date();
    cities.forEach(city => {
        const participant = sharedParticipants[city];
        const lastPost = participant.lastStakingYieldPostDate || now;
        const diffMs = now - lastPost;
        let periods = 0;

        if(freq === 'hour') { periods = Math.floor(diffMs / (1000 * 60 * 60)); }
        else { const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            if(freq === 'day') periods = diffDays;
            else if(freq === 'week') periods = Math.floor(diffDays / 7);
            else if(freq === 'month') periods = Math.floor(diffDays / 30);
        }

        if (periods > 0) {
            for (const c in participant.wallets) {
                if (participant.wallets[c] > 0) {
                    const yieldRate = STAKING_YIELDS[c];
                    const yieldAmount = participant.wallets[c] * yieldRate * periods;
                    participant.wallets[c] += yieldAmount;
                    addSharedTransaction(city, 'Staking Yield', `Received ${yieldAmount.toFixed(2)} ${c} in staking yield.`);
                }
            }
            participant.lastStakingYieldPostDate = now;
        }
    });
    addSharedAudit('Staking yield calculation complete.');
    updateAllDisplays();
}
// Dashboard Update Functions
function updateDashboard() {
  // Accounts
  const accountsDiv = document.getElementById('accountsSection');
  accountsDiv.innerHTML = '<h3>Accounts (Deposits)</h3>';
  cities.forEach(city => {
    const div = document.createElement('div');
    div.style.marginBottom = '10px';
    div.innerHTML = `<strong>${city}</strong> <span class="expandable" onclick="toggleDetails('${city}-accounts')">[+]</span>`;
    const details = document.createElement('div');
    details.id = `${city}-accounts`;
    details.className = 'hidden';
    details.style.marginLeft = '12px';
    currencies.forEach(c => {
      const val = sharedParticipants[city].accounts[c];
      const a = document.createElement('a');
      a.href = "#";
      a.textContent = `${c}: ${val.toFixed(2)}`;
      a.onclick = (e) => { e.preventDefault(); openModal(city, 'account', c); };
      details.appendChild(a);
      details.appendChild(document.createElement('br'));
    });
    div.appendChild(details);
    accountsDiv.appendChild(div);
  });
  // Wallets
  const walletsDiv = document.getElementById('walletsSection');
  walletsDiv.innerHTML = '<h3>Wallets (Tokens)</h3>';
  cities.forEach(city => {
    const div = document.createElement('div');
    div.style.marginBottom = '10px';
    div.innerHTML = `<strong>${city} (${sovereigns[city]})</strong> <span class="expandable" onclick="toggleDetails('${city}-wallets')">[+]</span>`;
    const details = document.createElement('div');
    details.id = `${city}-wallets`;
    details.className = 'hidden';
    details.style.marginLeft = '12px';
    currencies.forEach(c => {
      const val = sharedParticipants[city].wallets[c];
      const a = document.createElement('a');
      a.href = "#";
      a.textContent = `${c}: ${val.toFixed(2)}`;
      a.onclick = (e) => { e.preventDefault(); openModal(city, 'wallet', c) };
      details.appendChild(a);
      details.appendChild(document.createElement('br'));
    });
    div.appendChild(details);
    walletsDiv.appendChild(div);
  });
  // Loans
  const loansDiv = document.getElementById('loansSection');
  loansDiv.innerHTML = '<h3>Loan Accounts</h3>';
  cities.forEach(city => {
    const participant = sharedParticipants[city];
    const div = document.createElement('div');
    div.style.marginBottom = '10px';
    div.innerHTML = `<strong>${city}</strong> <span class="expandable" onclick="toggleDetails('${city}-loans')">[+]</span>`;

    const details = document.createElement('div');
    details.id = `${city}-loans`;
    details.className = 'hidden';
    details.style.marginLeft = '12px';

    // Aggregate borrowed amounts by currency
    const borrowedByCurrency = {};
    participant.borrowed.forEach(loan => {
        borrowedByCurrency[loan.currency] = (borrowedByCurrency[loan.currency] || 0) + loan.totalAmount;
    });

    currencies.forEach(c => {
      const val = borrowedByCurrency[c] || 0;
      if (val > 0) { // Only show currencies with active loans
        const a = document.createElement('a');
        a.href = "#";
        a.textContent = `${c}: ${val.toFixed(2)}`;
        a.onclick = (e) => { e.preventDefault(); openModal(city, 'loan', c); };
        details.appendChild(a);
        details.appendChild(document.createElement('br'));
      }
    });

    div.appendChild(details);
    loansDiv.appendChild(div);
  });
}
function toggleDetails(id) {
  const elem = document.getElementById(id);
  if (!elem) return;
  const expandable = elem.previousElementSibling.querySelector('.expandable');
  if(elem.classList.contains('hidden')) {
    elem.classList.remove('hidden');
    if(expandable) expandable.textContent = '[-]';
  } else {
    elem.classList.add('hidden');
    if(expandable) expandable.textContent = '[+]';
  }
}
// Liquidity & AMM Rendering
function renderWalletBalanceMatrix() {
    const container = document.getElementById('walletBalanceMatrix');
    container.innerHTML = ''; // Clear previous content
    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.fontSize = '0.8rem';

    // Table Header
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    const th = document.createElement('th');
    th.textContent = 'Country';
    headerRow.appendChild(th);
    currencies.forEach(c => {
        const th = document.createElement('th');
        th.textContent = c;
        headerRow.appendChild(th);
    });

    // Table Body
    const tbody = table.createTBody();
    const currencyTotals = currencies.reduce((acc, c) => ({ ...acc, [c]: 0 }), {});

    cities.forEach(city => {
        const row = tbody.insertRow();
        const th = document.createElement('th');
        th.textContent = city;
        row.appendChild(th);
        currencies.forEach(c => {
            const balance = sharedParticipants[city].wallets[c];
            currencyTotals[c] += balance;
            const cell = row.insertCell();
            cell.textContent = (balance / 1000000).toFixed(2); // Scale to millions
        });
    });

    // Table Footer with Totals
    const tfoot = table.createTFoot();
    const footerRow = tfoot.insertRow();
    const totalTh = document.createElement('th');
    totalTh.textContent = 'Total';
    footerRow.appendChild(totalTh);
    currencies.forEach(c => {
        const cell = footerRow.insertCell();
        cell.textContent = (currencyTotals[c] / 1000000).toFixed(2); // Scale to millions
        cell.style.fontWeight = 'bold';
    });

    container.appendChild(table);
}
function renderLiquidityAMMSection() {
  renderWalletBalanceMatrix();
  renderAmmMatrix();
}
function renderAmmMatrix() {
    const container = document.getElementById('ammMatrix');
    container.innerHTML = '';
    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.fontSize = '0.8rem';

    // Header Row
    const thead = document.createElement('thead');
    let headerRow = '<tr><th>&nbsp;</th>';
    currencies.forEach(c => headerRow += `<th>${c}</th>`);
    headerRow += '</tr>';
    thead.innerHTML = headerRow;
    table.appendChild(thead);

    // Body Rows
    const tbody = document.createElement('tbody');
    currencies.forEach(from_c => {
        let rowHtml = `<tr><th>${from_c}</th>`;
        const rates = network.ammService.getAmountOut(from_c, null, 1); // Get all rates for from_c
        currencies.forEach(to_c => {
            if (from_c === to_c) {
                rowHtml += `<td>1.00</td>`;
            } else {
                const rate = rates[to_c] || 0;
                rowHtml += `<td>${rate.toFixed(4)}</td>`;
            }
        });
        rowHtml += '</tr>';
        tbody.innerHTML += rowHtml;
    });
    table.appendChild(tbody);
    container.appendChild(table);
}
// ========== DLT NETWORK FUNCTIONS ==========
// Transaction class for network
class Transaction {
  constructor({id, type, from, to, currency, amount, meta}){
    this.id = id || 'tx-' + Math.random().toString(36).slice(2,9);
    this.type = type;
    this.from = from || null;
    this.to = to || null;
    this.currency = currency || null;
    this.amount = amount || 0;
    this.meta = meta || {};
    this.timestamp = new Date();
  }
}
// Network Services
class LiquidityPoolService{
  constructor(){
    this.pool = {};
    currencies.forEach(c=>this.pool[c]=0);
  }
  addLiquidity(currency, amount){ this.pool[currency] = (this.pool[currency]||0) + amount; }
  removeLiquidity(currency, amount){ this.pool[currency] = (this.pool[currency]||0) - amount; }
  borrow(currency, amount){
    if(this.pool[currency] < amount) throw new Error('insufficient pool');
    this.pool[currency] -= amount;
    return amount;
  }
  repay(currency, amount){ this.pool[currency] = (this.pool[currency]||0) + amount; }
  snapshot(){ return {...this.pool}; }
}
class AMMService{
  constructor(liquidity){ this.liquidity = liquidity; }
  getAmountOut(fromCurrency, toCurrency, amountIn){
    // If toCurrency is null, get all rates
    if (toCurrency === null) {
        const results = {};
        currencies.forEach(c => {
            if (c === fromCurrency) return;
            results[c] = this.getAmountOut(fromCurrency, c, amountIn);
        });
        return results;
    }

    const poolFrom = this.liquidity.pool[fromCurrency];
    const poolTo = this.liquidity.pool[toCurrency];
    if(!poolFrom || !poolTo) return 0;

    // Constant Sum: amountOut = amountIn
    const amountOut_sum = amountIn;

    // Constant Product
    const k = poolFrom * poolTo;
    const newPoolFrom = poolFrom + amountIn;
    const newPoolTo = k / newPoolFrom;
    const amountOut_prod = poolTo - newPoolTo;

    // Simple average, no fee for this model as per "remove slippage"
    return (amountOut_sum + amountOut_prod) / 2;
  }
  getAmountIn(fromCurrency, toCurrency, amountOut) {
    // Iterative approximation to find amountIn for the hybrid model
    let low = 0;
    let high = (this.liquidity.pool[fromCurrency] || 1) * 2; // Start with a high guess
    let mid, calc_out;

    for (let i = 0; i < 50; i++) { // 50 iterations for precision
        mid = (low + high) / 2;
        if (mid === 0) { low = 0; high = 0; break; }
        calc_out = this.getAmountOut(fromCurrency, toCurrency, mid);
        if (calc_out > amountOut) {
            high = mid;
        } else {
            low = mid;
        }
    }
    const requiredAmount = (low + high) / 2;
    return requiredAmount > 0 ? requiredAmount : Infinity;
  }
}
class Network{
  constructor(){
    this.nodes = {};
    cities.forEach(c=>this.nodes[c] = sharedParticipants[c]);
    this.liquidityService = new LiquidityPoolService();
    this.ammService = new AMMService(this.liquidityService);
    this.audit = [];
    this.currentLeader = cities[0];

    // Sync liquidity service with shared pool
    this.syncLiquidityService();
  }
  syncLiquidityService() {
    currencies.forEach(c => {
      this.liquidityService.pool[c] = sharedLiquidityPool[c];
    });
  }
  broadcastAndConsolidate(tx) {
    this.broadcastTx(tx);
    return this.runConsensus();
  }
  broadcastTx(tx){
    Object.values(this.nodes).forEach(n=>n.mempool.unshift(tx));
    this.audit.unshift({timestamp:new Date(), message:`Broadcast ${tx.type} ${tx.id}`});
    addSharedAudit(`Network broadcast ${tx.type} ${tx.id}`);
  }
  runConsensus() {
    this.syncLiquidityService();
    const leader = this.nodes[this.currentLeader];
    const processedTxs = [];

    // Process all transactions from the leader's mempool
    while (leader.mempool.length > 0) {
        const tx = leader.mempool.pop(); // Process in LIFO order
        processedTxs.push(tx);
    }

    if (processedTxs.length === 0) {
        return { success: true, message: "No transactions in mempool." };
    }

    let successfulTxs = 0;
    let finalMessage = "";
    let allSucceeded = true;

    processedTxs.forEach(tx => {
        const validationResult = this.validateTransaction(tx);
        if (validationResult.valid) {
            this.executeTransaction(tx); // Centralized execution
            addSharedAudit(`Transaction ${tx.id} (${tx.type}) was successfully processed.`);
            successfulTxs++;

            // After a transaction is successfully executed, it must be removed from all mempools.
            Object.values(this.nodes).forEach(node => {
                node.mempool = node.mempool.filter(mempoolTx => mempoolTx.id !== tx.id);
            });
        } else {
            allSucceeded = false;
            finalMessage = `Transaction Failed: ${validationResult.message}`;
            addSharedAudit(`Transaction ${tx.id} (${tx.type}) failed: ${validationResult.message}`);
        }
    });

    if (processedTxs.length > 1) {
        finalMessage = `Consensus round processed ${successfulTxs} of ${processedTxs.length} transactions.`;
    } else if (allSucceeded) {
        finalMessage = 'Transaction Successful!';
    }

    this.audit.unshift({ timestamp: new Date(), message: `Consensus round by ${this.currentLeader} processed ${successfulTxs}/${processedTxs.length} transactions.` });

    const idx = cities.indexOf(this.currentLeader);
    this.currentLeader = cities[(idx + 1) % cities.length];
    recalcSharedLiquidityPool();

    return { success: allSucceeded, message: finalMessage };
  }

  validateTransaction(tx) {
    const participant = this.nodes[tx.from];
    if (!participant) {
        return { valid: false, message: `Invalid participant: ${tx.from}` };
    }

    switch (tx.type) {
            case 'swap_and_transfer':
                if (participant.name === tx.from) {
                    const { swapFrom, swapAmountIn, neededForTransfer } = tx.meta;
                    const amountOut = this.ammService.getAmountOut(swapFrom, tx.currency, swapAmountIn);

                    if (amountOut < neededForTransfer * 0.99) { // Allow 1% slippage
                        addSharedTransaction(participant.name, 'Swap Failed', `Swap for ${tx.currency} resulted in insufficient funds.`);
                        // In a real system, this would fail the transaction.
                        return;
                    }

                    // Perform swap
                    participant.wallets[swapFrom] -= swapAmountIn;
                    participant.wallets[tx.currency] += amountOut;
                    addSharedTransaction(participant.name, 'Swap', `Swapped ${swapAmountIn.toFixed(2)} ${swapFrom} for ${amountOut.toFixed(2)} ${tx.currency}`);

                    // Perform transfer
                    participant.wallets[tx.currency] -= tx.amount;
                    addSharedTransaction(participant.name, 'Transfer Out', `Transferred ${tx.amount.toFixed(2)} ${tx.currency} to ${tx.to}`);
                }
                if (participant.name === tx.to) {
                    participant.wallets[tx.currency] += tx.amount;
                    addSharedTransaction(participant.name, 'Transfer In', `Received ${tx.amount.toFixed(2)} ${tx.currency} from ${tx.from}`);
                }
                break;
        case 'tokenize': {
            if (participant.accounts[tx.currency] < tx.amount) {
                return { valid: false, message: `Insufficient deposit to tokenize ${tx.amount} ${tx.currency}.` };
            }
            break;
        }
        case 'transfer': {
            if (participant.wallets[tx.currency] < tx.amount) {
                return { valid: false, message: `Insufficient funds for transfer.` };
            }
            break;
        }
        case 'borrow_and_transfer': {
            const balance = participant.wallets[tx.currency];
            if (balance < tx.amount) {
                const needed = tx.amount - balance;
                if (this.liquidityService.pool[tx.currency] < needed) {
                    return { valid: false, message: `Insufficient liquidity to borrow ${needed.toFixed(2)}.` };
                }
            }
            break;
        }
        case 'burn': {
            if (participant.wallets[tx.currency] < tx.amount) {
                return { valid: false, message: `Insufficient tokens to burn.` };
            }
            break;
        }
        case 'swap': {
            const { fromCurrency, amountIn } = tx.meta;
            if (participant.wallets[fromCurrency] < amountIn) {
                return { valid: false, message: `Insufficient ${fromCurrency} to swap.` };
            }
            break;
        }
        case 'repay': {
            if (participant.wallets[tx.currency] < tx.amount) {
                return { valid: false, message: `Insufficient tokens to repay.` };
            }
            break;
        }
        case 'swap_and_transfer': {
            const { swapFrom, swapAmountIn } = tx.meta;
            if (participant.wallets[swapFrom] < swapAmountIn) {
                return { valid: false, message: `Insufficient ${swapFrom} to perform swap.` };
            }
            break;
        }
        case 'swap_and_repay': {
            const { loanId, swapFrom, swapAmountIn } = tx.meta;
            if (participant.wallets[swapFrom] < swapAmountIn) {
                return { valid: false, message: `Insufficient ${swapFrom} to perform swap for repayment.` };
            }
            const loanToRepay = participant.borrowed.find(l => l.loanId === loanId);
            if (!loanToRepay) {
                return { valid: false, message: `Loan with ID ${loanId} not found for repayment.`};
            }
            if (loanToRepay.totalAmount < tx.amount) {
                return { valid: false, message: `Repay amount is greater than outstanding loan.`};
            }
            break;
        }
    }
    // If no validation fails, the transaction is valid.
    return { valid: true };
  }

  executeTransaction(tx) {
    const from = this.nodes[tx.from];
    const to = this.nodes[tx.to];

    // The core logic for state changes.
    switch (tx.type) {
        case 'tokenize':
            from.accounts[tx.currency] -= tx.amount;
            from.wallets[tx.currency] += tx.amount;
            addSharedTransaction(tx.from, 'Tokenize', `Tokenized ${tx.amount.toFixed(2)} ${tx.currency}`);
            break;
        case 'transfer':
            from.wallets[tx.currency] -= tx.amount;
            to.wallets[tx.currency] += tx.amount;
            addSharedTransaction(tx.from, 'Transfer Out', `Transferred ${tx.amount.toFixed(2)} ${tx.currency} to ${tx.to}`);
            addSharedTransaction(tx.to, 'Transfer In', `Received ${tx.amount.toFixed(2)} ${tx.currency} from ${tx.from}`);
            break;
        case 'burn':
            from.wallets[tx.currency] -= tx.amount;
            from.accounts[tx.currency] += tx.amount;
            addSharedTransaction(tx.from, 'Burn', `Burned ${tx.amount.toFixed(2)} ${tx.currency}`);
            break;
        case 'swap':
            const { fromCurrency, toCurrency, amountIn } = tx.meta;
            const amountOut = this.ammService.getAmountOut(fromCurrency, toCurrency, amountIn);
            if (amountOut > 0) {
                from.wallets[fromCurrency] -= amountIn;
                from.wallets[toCurrency] += amountOut;
                addSharedTransaction(tx.from, 'Swap', `Swapped ${amountIn.toFixed(2)} ${fromCurrency} for ${amountOut.toFixed(2)} ${toCurrency}`);
            }
            break;
        case 'repay': {
            const { loanId } = tx.meta;
            const loanIndex = from.borrowed.findIndex(l => l.loanId === loanId);
            if (loanIndex === -1) break;

            const loan = from.borrowed[loanIndex];
            const originalTotal = loan.lenders.reduce((sum, l) => sum + l.amount, 0);

            // Credit lenders proportionally
            loan.lenders.forEach(lender => {
                const proportion = lender.amount / originalTotal;
                const creditAmount = tx.amount * proportion;
                this.nodes[lender.name].wallets[tx.currency] += creditAmount;
                addSharedTransaction(lender.name, 'Repayment Received', `Received ${creditAmount.toFixed(2)} ${tx.currency} for loan ${loanId}`);
            });

            // Debit borrower
            from.wallets[tx.currency] -= tx.amount;
            addSharedTransaction(tx.from, 'Repay', `Repaid ${tx.amount.toFixed(2)} ${tx.currency} for loan ${loanId}`);

            // Update loan records for borrower and lenders
            from.borrowed[loanIndex].totalAmount -= tx.amount;
            if (from.borrowed[loanIndex].totalAmount <= 0.01) { // If fully paid
                from.borrowed.splice(loanIndex, 1);
                // Remove from all lenders' records
                Object.values(this.nodes).forEach(node => {
                    node.loans = node.loans.filter(l => l.loanId !== loanId);
                });
            }
            break;
        }
        case 'borrow_and_transfer':
            const { borrowAmount } = tx.meta;
            const totalLiquidity = this.liquidityService.pool[tx.currency];
            const loanId = 'loan-' + Math.random().toString(36).slice(2, 11);

            const lenders = [];
            // Debit all providers proportionally and record them as lenders
            if (totalLiquidity > 0) {
                Object.values(this.nodes).forEach(p_node => {
                    const contribution = p_node.wallets[tx.currency];
                    if (contribution > 0) {
                        const proportion = contribution / totalLiquidity;
                        const amountLent = borrowAmount * proportion;
                        p_node.wallets[tx.currency] -= amountLent;

                        const lenderRecord = { name: p_node.name, amount: amountLent };
                        lenders.push(lenderRecord);

                        // Add a record to the lender's "loans" array
                        this.nodes[p_node.name].loans.push({
                            loanId: loanId,
                            currency: tx.currency,
                            amountLent: amountLent,
                            borrower: tx.from
                        });
                        addSharedTransaction(p_node.name, 'Lend', `Lent ${amountLent.toFixed(2)} ${tx.currency} for loan ${loanId}`);
                    }
                });
            }

            // Add the new loan object to the borrower's "borrowed" array
            from.borrowed.push({
                loanId: loanId,
                currency: tx.currency,
                totalAmount: borrowAmount,
                lenders: lenders,
                lastInterestPostDate: new Date()
            });
            addSharedTransaction(tx.from, 'Borrow', `Borrowed ${borrowAmount.toFixed(2)} ${tx.currency} (Loan: ${loanId})`);

            // Execute the transfer
            from.wallets[tx.currency] += borrowAmount;
            from.wallets[tx.currency] -= tx.amount;
            to.wallets[tx.currency] += tx.amount;
            addSharedTransaction(tx.from, 'Transfer Out', `Transferred ${tx.amount.toFixed(2)} ${tx.currency} to ${tx.to}`);
            addSharedTransaction(tx.to, 'Transfer In', `Received ${tx.amount.toFixed(2)} ${tx.currency} from ${tx.from}`);
            break;
        case 'swap_and_repay': {
            const { loanId, swapFrom, swapAmountIn } = tx.meta;

            // 1. Perform Swap
            const swapAmountOut = this.ammService.getAmountOut(swapFrom, tx.currency, swapAmountIn);
            from.wallets[swapFrom] -= swapAmountIn;
            from.wallets[tx.currency] += swapAmountOut;
            addSharedTransaction(tx.from, 'Swap', `Swapped ${swapAmountIn.toFixed(2)} ${swapFrom} for repayment`);

            // 2. Perform Repayment (logic is identical to 'repay' case)
            const loanIndex = from.borrowed.findIndex(l => l.loanId === loanId);
            if (loanIndex === -1) break;

            const loan = from.borrowed[loanIndex];
            const originalTotal = loan.lenders.reduce((sum, l) => sum + l.amount, 0);

            loan.lenders.forEach(lender => {
                const proportion = lender.amount / originalTotal;
                const creditAmount = tx.amount * proportion;
                this.nodes[lender.name].wallets[tx.currency] += creditAmount;
                addSharedTransaction(lender.name, 'Repayment Received', `Received ${creditAmount.toFixed(2)} ${tx.currency} for loan ${loanId}`);
            });

            from.wallets[tx.currency] -= tx.amount;
            addSharedTransaction(tx.from, 'Repay', `Repaid ${tx.amount.toFixed(2)} ${tx.currency} for loan ${loanId}`);

            from.borrowed[loanIndex].totalAmount -= tx.amount;
            if (from.borrowed[loanIndex].totalAmount <= 0.01) {
                from.borrowed.splice(loanIndex, 1);
                Object.values(this.nodes).forEach(node => {
                    node.loans = node.loans.filter(l => l.loanId !== loanId);
                });
            }
            break;
        }
        case 'swap_and_transfer':
            const { swapFrom, swapAmountIn, neededForTransfer } = tx.meta;
            const swapAmountOut = this.ammService.getAmountOut(swapFrom, tx.currency, swapAmountIn);

            if (swapAmountOut < neededForTransfer * 0.99) { // Allow 1% slippage
                addSharedTransaction(tx.from, 'Swap Failed', `Swap for ${tx.currency} resulted in insufficient funds.`);
                // In a more robust system, this would throw an error to fail the transaction.
                return;
            }

            // Perform swap
            from.wallets[swapFrom] -= swapAmountIn;
            from.wallets[tx.currency] += swapAmountOut;
            addSharedTransaction(tx.from, 'Swap', `Swapped ${swapAmountIn.toFixed(2)} ${swapFrom} for ${swapAmountOut.toFixed(2)} ${tx.currency}`);

            // Perform transfer
            from.wallets[tx.currency] -= tx.amount;
            to.wallets[tx.currency] += tx.amount;
            addSharedTransaction(tx.from, 'Transfer Out', `Transferred ${tx.amount.toFixed(2)} ${tx.currency} to ${tx.to}`);
            addSharedTransaction(tx.to, 'Transfer In', `Received ${tx.amount.toFixed(2)} ${tx.currency} from ${tx.from}`);
            break;
        case 'swap_and_repay': {
            const { swapFrom, swapAmountIn } = tx.meta;
            const neededForRepay = tx.amount - from.wallets[tx.currency];

            // Perform Swap
            const swapAmountOut = this.ammService.getAmountOut(swapFrom, tx.currency, swapAmountIn);
            if (swapAmountOut < neededForRepay * 0.99) { // Allow 1% slippage
                addSharedTransaction(tx.from, 'Swap Failed', `Swap for repayment resulted in insufficient funds.`);
                return;
            }
            from.wallets[swapFrom] -= swapAmountIn;
            from.wallets[tx.currency] += swapAmountOut;
            addSharedTransaction(tx.from, 'Swap', `Swapped ${swapAmountIn.toFixed(2)} ${swapFrom} for ${swapAmountOut.toFixed(2)} ${tx.currency} for repayment`);

            // Perform Repayment (logic is identical to 'repay' case)
            const loanIndex = from.borrowed.findIndex(l => l.loanId === loanId);
            if (loanIndex === -1) break;

            const loan = from.borrowed[loanIndex];
            const originalTotal = loan.lenders.reduce((sum, l) => sum + l.amount, 0);

            loan.lenders.forEach(lender => {
                const proportion = lender.amount / originalTotal;
                const creditAmount = tx.amount * proportion;
                this.nodes[lender.name].wallets[tx.currency] += creditAmount;
                addSharedTransaction(lender.name, 'Repayment Received', `Received ${creditAmount.toFixed(2)} ${tx.currency} for loan ${loanId}`);
            });

            from.wallets[tx.currency] -= tx.amount;
            addSharedTransaction(tx.from, 'Repay', `Repaid ${tx.amount.toFixed(2)} ${tx.currency} for loan ${loanId}`);

            from.borrowed[loanIndex].totalAmount -= tx.amount;
            if (from.borrowed[loanIndex].totalAmount <= 0.01) {
                from.borrowed.splice(loanIndex, 1);
                Object.values(this.nodes).forEach(node => {
                    node.loans = node.loans.filter(l => l.loanId !== loanId);
                });
            }
            break;
        }
    }

    // After state changes, add the transaction to every node's chain.
    Object.values(this.nodes).forEach(node => {
        if (!node.chain.some(t => t.id === tx.id)) {
            node.chain.unshift(tx);
        }
    });
  }
}
let network;
function initializeNetwork() {
  network = new Network();
}
// Network UI Functions (now unused, can be removed later)
function uiTokenize(){}
function uiTransfer(){}
function uiSwap(){}
function runConsensusRound() {}
function syncAllNodes() {}
// Network Rendering Functions
function renderNodesList(){
  const nodesList = document.getElementById('nodesList');
  if (!nodesList) return;
  nodesList.innerHTML='';
  Object.values(network.nodes).forEach(n=>{
    const div=document.createElement('div');
    div.className='nodeItem';
    div.innerHTML = `<div><span class='nodeBadge'>${n.name}</span> <span class='muted'>(${sovereigns[n.name]})</span></div><div class='muted'>Wallet ${n.wallets[sovereigns[n.name]].toFixed(0)}</div>`;
    nodesList.appendChild(div);
  });
}
function renderNodesGrid(){
  const grid = document.getElementById('nodesGrid');
  if (!grid) return;
  grid.innerHTML='';
  cities.forEach(city => {
    const n = sharedParticipants[city];
    const card=document.createElement('div');
    card.className='nodeCard';
    let inner = `<strong>${city}</strong><div class='mini'>Sovereign ${sovereigns[city]}</div><div style='margin-top:6px'><em class='mini'>Wallets</em>`;
    currencies.forEach(c=>{ inner += `<div style='font-size:0.85rem'>${c}: ${n.wallets[c].toFixed(2)}</div>`; });
    inner += `</div><div style='margin-top:8px'><button onclick="inspectNode('${city}')">Inspect</button></div>`;
    card.innerHTML = inner;
    grid.appendChild(card);
  });
}
function renderNetworkCanvas(){
  const c = document.getElementById('networkCanvas');
  if (!c) return;
  const ctx = c.getContext('2d');
  const W=c.width=320; const H=c.height=360;
  ctx.clearRect(0,0,W,H);
  const cx=W/2, cy=H/2, r=120; const n=cities.length;
  ctx.font='12px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  const nodesPos = {};
  cities.forEach((city,i)=>{
    const angle = (i/n) * Math.PI*2 - Math.PI/2;
    const x = cx + Math.cos(angle)*r; const y = cy + Math.sin(angle)*r;
    nodesPos[city]={x,y};
  });
  ctx.strokeStyle='rgba(20,90,150,0.06)'; ctx.lineWidth=1; ctx.beginPath();
  cities.forEach(a=>{
    cities.forEach(b=>{
      if(a===b) return;
      ctx.moveTo(nodesPos[a].x,nodesPos[a].y);
      ctx.lineTo(nodesPos[b].x,nodesPos[b].y);
    });
  });
  ctx.stroke();
  cities.forEach(city=>{
    const p = nodesPos[city];
    ctx.beginPath();
    ctx.fillStyle='#fff';
    ctx.strokeStyle='#0b66b2';
    ctx.lineWidth=2;
    ctx.arc(p.x,p.y,18,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle='#0b66b2';
    ctx.fillText(city,p.x,p.y);
  });
}
function inspectNode(name){
  const node = sharedParticipants[name];
  let detail = `Node: ${name}\nSovereign: ${sovereigns[name]}\n\nWallets:\n`;
  currencies.forEach(c=> detail += `${c}: ${node.wallets[c].toFixed(2)}\n`);
  detail += '\nRecent chain entries:\n';
  node.chain.slice(0,10).forEach(t=> detail += `${t.timestamp.toLocaleString()} ${t.type} ${t.currency||''} ${t.amount||''}\n`);
  alert(detail);
}
function renderAllNetwork() {
  if (network) {
    renderNodesList();
    renderNodesGrid();
    renderAmmMatrix();
    renderNetworkCanvas();
  }
}
// ========== SHARED FUNCTIONS ==========
function updateAllDisplays() {
  console.log("Updating all displays...");
  recalcSharedLiquidityPool();
  if (network) {
    network.syncLiquidityService();
  }

  // Render all components since there are no tabs
  updateDashboard();
  renderLiquidityAMMSection();
  renderInterestRateTable();
  renderStakingYieldTable();
  renderAllNetwork();

  console.log("Display update complete.");
}
function populateDropdowns() {
  const participantSelects = ['tokenizeParticipant', 'sender', 'receiver', 'burnParticipant', 'ammParticipant', 'repayParticipant'];
  participantSelects.forEach(id => {
    const sel = document.getElementById(id);
    if (sel) {
      sel.innerHTML = '';
      cities.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c;
        opt.textContent = c;
        sel.appendChild(opt);
      });
    }
  });
  const currencySelects = ['tokenizeCurrency', 'transferCurrency', 'burnCurrency', 'ammFromCurrency', 'ammToCurrency', 'repayCurrency', 'liquidityCurrency'];
  currencySelects.forEach(id => {
    const sel = document.getElementById(id);
    if (sel) {
      sel.innerHTML = '';
      currencies.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c;
        opt.textContent = c;
        sel.appendChild(opt);
      });
    }
  });
  // Network UI dropdowns (kept for potential future use)
  const networkSelects = ['ui_sender', 'ui_receiver'];
  networkSelects.forEach(id => {
    const sel = document.getElementById(id);
    if (sel) {
      sel.innerHTML = '';
      cities.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c;
        opt.textContent = c;
        sel.appendChild(opt);
      });
    }
  });
  const networkCurrencySelect = document.getElementById('ui_currency');
  if (networkCurrencySelect) {
    networkCurrencySelect.innerHTML = '';
    currencies.forEach(c => {
      const opt = document.createElement('option');
      opt.value = c;
      opt.textContent = c;
      networkCurrencySelect.appendChild(opt);
    });
  }
  // Default values
  const liquidityCurrencySelect = document.getElementById('liquidityCurrency');
  if (liquidityCurrencySelect) liquidityCurrencySelect.value = 'USD';

  populateLoanDropdown();
}
// ========== MODAL FUNCTIONS ==========
// Modal for transaction history (accounts/wallets/loans)
const modalOverlay = document.getElementById('modalOverlay');
const modalTitle = document.getElementById('modalTitle');
const modalTable = document.getElementById('modalTable');
const modalSearch = document.getElementById('modalSearch');
function openModal(city, type, currency) {
  modalOverlay.style.display = 'flex';
  modalSearch.value = '';
  modalTitle.textContent = `${city} - ${type} transactions (${currency})`;
  const tbody = modalTable.querySelector('tbody');
  tbody.innerHTML = '';
  let txs;
  if(type === 'account') {
    txs = sharedParticipants[city].transactions.filter(tx =>
      tx.details.includes(currency) &&
      (tx.details.toLowerCase().includes('deposit') ||
       tx.details.toLowerCase().includes('tokenize') ||
       tx.details.toLowerCase().includes('burn') ||
       tx.details.toLowerCase().includes('interest'))
    );
  } else if(type === 'wallet') {
    txs = sharedParticipants[city].transactions.filter(tx =>
      tx.details.includes(currency) &&
      (tx.details.toLowerCase().includes('transfer') ||
       tx.details.toLowerCase().includes('swap') ||
       tx.details.toLowerCase().includes('borrow') ||
       tx.details.toLowerCase().includes('repay'))
    );
  } else if(type === 'loan') {
    txs = sharedParticipants[city].transactions.filter(tx =>
      tx.details.includes(currency) &&
      (tx.type === 'Borrow' || tx.type === 'Repay' || tx.type === 'Interest Posting')
    );
  } else {
    txs = [];
  }
  if(txs.length === 0) {
    tbody.innerHTML = `<tr><td colspan="3" style="text-align:center;">No transactions found.</td></tr>`;
    return;
  }
  txs.forEach(tx => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${tx.timestamp.toLocaleString()}</td><td>${tx.type}</td><td>${tx.details}</td>`;
    tbody.appendChild(tr);
  });
}
function closeModal() {
  modalOverlay.style.display = 'none';
}
function filterModalTable() {
  const filter = modalSearch.value.toLowerCase();
  const rows = modalTable.querySelectorAll('tbody tr');
  rows.forEach(row => {
    const txt = row.textContent.toLowerCase();
    row.style.display = txt.includes(filter) ? '' : 'none';
  });
}
// Audit Modal
const auditModalOverlay = document.getElementById('auditModalOverlay');
const auditTable = document.getElementById('auditTable');
const auditSearch = document.getElementById('auditSearch');
function openAuditModal() {
  auditModalOverlay.style.display = 'flex';
  auditSearch.value = '';
  renderAuditTable();
}
function closeAuditModal() {
  auditModalOverlay.style.display = 'none';
}
function renderAuditTable() {
  const tbody = auditTable.querySelector('tbody');
  tbody.innerHTML = '';

  const allEvents = [];

  // Add network-level audit messages
  sharedAuditTrail.forEach(entry => {
    allEvents.push({
      timestamp: entry.timestamp,
      source: 'Network',
      type: 'DLT Event',
      message: entry.message
    });
  });

  // Add participant-level transactions
  cities.forEach(city => {
    const participant = sharedParticipants[city];
    participant.transactions.forEach(tx => {
      allEvents.push({
        timestamp: tx.timestamp,
        source: city,
        type: 'Business Transaction',
        message: `${tx.type}: ${tx.details}`
      });
    });
  });

  // Sort all events by timestamp, descending
  allEvents.sort((a, b) => b.timestamp - a.timestamp);

  // Render the combined list, limited to the most recent 200 entries
  allEvents.slice(0, 200).forEach(entry => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${entry.timestamp.toLocaleString()}</td><td>${entry.source}</td><td>${entry.type}</td><td>${entry.message}</td>`;
    tbody.appendChild(tr);
  });
}
function filterAuditTable() {
  const filter = modalSearch.value.toLowerCase();
  const rows = auditTable.querySelectorAll('tbody tr');
  rows.forEach(row => {
    const txt = row.textContent.toLowerCase();
    row.style.display = txt.includes(filter) ? '' : 'none';
  });
}

function renderInterestRateTable() {
    const tableHead = document.getElementById('interestRateTable').querySelector('thead tr');
    tableHead.innerHTML = `<th>Currency</th><th>Deposit Rate (%)</th><th>Lending Rate (%)</th>`;

    const tableBody = document.getElementById('interestRateTable').querySelector('tbody');
    tableBody.innerHTML = ''; // Clear existing rows

    for (const currency in INTEREST_RATES) {
        if (!currencies.includes(currency)) continue; // Only show active currencies
        const rates = INTEREST_RATES[currency];
        const row = document.createElement('tr');

        row.innerHTML = `
            <td>${currency}</td>
            <td><input type="number" value="${(rates.credit * 100).toFixed(4)}" step="0.01" onchange="updateInterestRate('${currency}', 'credit', this.value)" style="width: 100px;"></td>
            <td><input type="number" value="${(rates.debit * 100).toFixed(4)}" step="0.01" onchange="updateInterestRate('${currency}', 'debit', this.value)" style="width: 100px;"></td>
        `;
        tableBody.appendChild(row);
    }
}

function updateInterestRate(currency, type, value) {
    const rateAsPercent = parseFloat(value);
    if (!isNaN(rateAsPercent) && rateAsPercent >= 0) {
        INTEREST_RATES[currency][type] = rateAsPercent / 100; // Store as decimal
        addSharedAudit(`Updated ${currency} ${type} interest rate to ${rateAsPercent}%.`);
    } else {
        alert('Invalid interest rate. Please enter a non-negative number.');
        renderInterestRateTable(); // Re-render to show the old value
    }
}

function renderStakingYieldTable() {
    const tableHead = document.getElementById('stakingYieldTable').querySelector('thead tr');
    tableHead.innerHTML = `<th>Currency</th><th>Yield Rate (%)</th>`;

    const tableBody = document.getElementById('stakingYieldTable').querySelector('tbody');
    tableBody.innerHTML = ''; // Clear existing rows

    for (const currency in STAKING_YIELDS) {
        if (!currencies.includes(currency)) continue; // Only show active currencies
        const yieldRate = STAKING_YIELDS[currency];
        const row = document.createElement('tr');

        row.innerHTML = `
            <td>${currency}</td>
            <td><input type="number" value="${(yieldRate * 100).toFixed(4)}" step="0.01" onchange="updateStakingYield('${currency}', this.value)" style="width: 100px;"></td>
        `;
        tableBody.appendChild(row);
    }
}

function updateStakingYield(currency, value) {
    const rateAsPercent = parseFloat(value);
    if (!isNaN(rateAsPercent) && rateAsPercent >= 0) {
        STAKING_YIELDS[currency] = rateAsPercent / 100; // Store as decimal
        addSharedAudit(`Updated ${currency} staking yield to ${rateAsPercent}%.`);
    } else {
        alert('Invalid staking yield. Please enter a non-negative number.');
        renderStakingYieldTable(); // Re-render to show the old value
    }
}

// ========== INITIALIZATION ==========
function initializeSystem() {
  console.log("1. Starting system initialization...");
  initializeSharedSystem();
  console.log("2. Shared system initialized.");
  initializeNetwork();
  console.log("3. DLT Network initialized.");
  populateDropdowns();
  console.log("4. Dropdowns populated.");
  updateDashboard();
  console.log("5. Dashboard updated.");
  renderLiquidityAMMSection();
  console.log("6. Liquidity/AMM section rendered.");
  renderInterestRateTable();
  renderStakingYieldTable();
  renderAllNetwork();
  console.log("7. Full network rendered. Initialization complete.");
}
// Initialize on page load
window.addEventListener('DOMContentLoaded', initializeSystem);
// Close modals on outside click or Esc
window.onclick = function(event) {
  if(event.target === modalOverlay) closeModal();
  if(event.target === auditModalOverlay) closeAuditModal();
  if(event.target === statusModalOverlay) hideStatusModal();
};
window.onkeydown = function(event) {
  if(event.key === "Escape") {
    closeModal();
    closeAuditModal();
    hideStatusModal();
  }
};
// Expose shared system to console for debugging
window.sharedParticipants = sharedParticipants;
window.network = network;
</script>
</body>
</html>
